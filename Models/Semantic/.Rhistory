for(t in 1:100){
p=nextDistrib(p)
pops=append(pops,p);times=append(times,rep(t,n))
show(mean(p))
}
g=ggplot(data.frame(pops,times))
g+geom_density(aes(x=pops,colour=as.character(times)),show.legend=FALSE)+xlim(c(-2,20))
hist(p,plot=FALSE)
p0 = rlnorm(n)
#p0=runif(n)
growthRates<-function(){rnorm(n,mean=1,sd = 0.05)}
nextDistrib <- function(p){sample(growthRates()*p,n)}
pops=p0;times=rep(0,n)
p=p0
for(t in 1:100){
p=nextDistrib(p)
pops=append(pops,p);times=append(times,rep(t,n))
show(mean(p))
}
p0=runif(n)
growthRates<-function(){rnorm(n,mean=1,sd = 0.05)}
nextDistrib <- function(p){sample(growthRates()*p,n)}
pops=p0;times=rep(0,n)
p=p0
for(t in 1:100){
p=nextDistrib(p)
pops=append(pops,p);times=append(times,rep(t,n))
show(mean(p))
}
gc()
gc()
spatializedExpMixtureDensity <- function(gridSize,N,alpha,proba=TRUE,rmin=0,rmax=0,Pmax=1,tolThreshold=0,kernel_type="poisson"){
if(rmin==0){rmin = gridSize/N}
if(rmax==0){rmax = gridSize/N}
# patches of the grid are 1 unit size (in r_min/max units)
grid = matrix(0,gridSize,gridSize)
# matrix of coordinates
coords = matrix(c(c(matrix(rep(1:gridSize,gridSize),nrow=gridSize)),c(matrix(rep(1:gridSize,gridSize),nrow=gridSize,byrow=TRUE))),nrow=gridSize^2)
# first draw param distribs ? not needed
# for exp distribs, P_i = 2pi*d_i*r_i^2
#  -> take P from deterministic distrib ; draw r.
for(i in 1:N){
#show(i)
pop_i = Pmax*i^{-alpha}
r_i = runif(1,min=rmin,max=rmax)
d_i = pop_i / (2*pi*(r_i^2))
# find origin of that kernel
#  -> one of points such that : d(bord) > rcut and \forall \vec{x}\in D(rcut),d(\vec{x})<tolThr.
#pot = which(!pseudoClosing(grid>tolThreshold,r_i),arr.ind=TRUE)
#show(length(pot))
#if(length(pot)==0){
#  # Take a point with minimal density ?
#  pot = which(grid==min(grid),arr.ind=TRUE)
#}
# simplify : take deterministiquely (almost, after two exps only two points possible)
# BUT not close to border
#rbord = 2*rmax*log(Pmax/tolThreshold)
rbord = 2*rmax
# random center
if(max(grid)==0){
# random if no center yet
center = matrix(runif(2,min=rbord+1,max=gridSize-rbord),nrow=1)
}
else {
# else find min pop area not too close to border
pot = which(grid==min(grid[(rbord+1):(gridSize-rbord),(rbord+1):(gridSize-rbord)]),arr.ind=TRUE)
row = sample(nrow(pot),1)
center = matrix(pot[row,],nrow=1)
}
# add kernel : use kernlab laplace kernel or other
if(kernel_type=="poisson"){ker=laplacedot(sigma=1/r_i)}
if(kernel_type=="gaussian"){ker=rbfdot(sigma=1/(2*r_i^2))}
#if(kernel_type="quadratic"){ker=} # is quad kernel available ?
grid = grid + (d_i * matrix(kernelMatrix(kernel=laplacedot(sigma=1/r_i),x=coords,y=center),nrow=gridSize))
}
if(proba==TRUE){grid = grid / sum(grid)}
return(grid)
}
test = spatializedExpMixtureDensity(100,2,0.7)
library(kernlab)
test = spatializedExpMixtureDensity(100,10,0.7)
#test = spatializedExpMixtureDensity(100,3,0.7)
test = spatializedExpMixtureDensity(100,3,0.7)
test = spatializedExpMixtureDensity(100,4,0.7)
test = spatializedExpMixtureDensity(100,5,0.7)
spatializedExpMixtureDensity <- function(gridSize,N,alpha,proba=TRUE,rmin=0,rmax=0,Pmax=1,tolThreshold=0,kernel_type="poisson"){
if(rmin==0){rmin = gridSize/N}
if(rmax==0){rmax = gridSize/N}
# patches of the grid are 1 unit size (in r_min/max units)
grid = matrix(0,gridSize,gridSize)
# matrix of coordinates
coords = matrix(c(c(matrix(rep(1:gridSize,gridSize),nrow=gridSize)),c(matrix(rep(1:gridSize,gridSize),nrow=gridSize,byrow=TRUE))),nrow=gridSize^2)
# first draw param distribs ? not needed
# for exp distribs, P_i = 2pi*d_i*r_i^2
#  -> take P from deterministic distrib ; draw r.
for(i in 1:N){
show(i)
pop_i = Pmax*i^{-alpha}
r_i = runif(1,min=rmin,max=rmax)
d_i = pop_i / (2*pi*(r_i^2))
# find origin of that kernel
#  -> one of points such that : d(bord) > rcut and \forall \vec{x}\in D(rcut),d(\vec{x})<tolThr.
#pot = which(!pseudoClosing(grid>tolThreshold,r_i),arr.ind=TRUE)
#show(length(pot))
#if(length(pot)==0){
#  # Take a point with minimal density ?
#  pot = which(grid==min(grid),arr.ind=TRUE)
#}
# simplify : take deterministiquely (almost, after two exps only two points possible)
# BUT not close to border
#rbord = 2*rmax*log(Pmax/tolThreshold)
rbord = 2*rmax
# random center
if(max(grid)==0){
# random if no center yet
center = matrix(runif(2,min=rbord+1,max=gridSize-rbord),nrow=1)
}
else {
# else find min pop area not too close to border
pot = which(grid==min(grid[(rbord+1):(gridSize-rbord),(rbord+1):(gridSize-rbord)]),arr.ind=TRUE)
row = sample(nrow(pot),1)
center = matrix(pot[row,],nrow=1)
}
# add kernel : use kernlab laplace kernel or other
if(kernel_type=="poisson"){ker=laplacedot(sigma=1/r_i)}
if(kernel_type=="gaussian"){ker=rbfdot(sigma=1/(2*r_i^2))}
#if(kernel_type="quadratic"){ker=} # is quad kernel available ?
grid = grid + (d_i * matrix(kernelMatrix(kernel=laplacedot(sigma=1/r_i),x=coords,y=center),nrow=gridSize))
}
if(proba==TRUE){grid = grid / sum(grid)}
return(grid)
}
test = spatializedExpMixtureDensity(100,5,0.7)
test = spatializedExpMixtureDensity(100,4,0.7)
test = spatializedExpMixtureDensity(100,5,0.7)
persp3D(z=test)
library(plot3D)
persp3D(z=test)
test = spatializedExpMixtureDensity(100,10,0.7)
test = spatializedExpMixtureDensity(100,20,0.7)
persp3D(z=test)
library(igraph)
hep(simplify())
help(simplify)
localGraph=list()
localGraph$gg
is.null(localGraph$gg)
48*400
help(try)
#'   ! assuming q > 0
quantilesToHist<-function(q){
mids=c();density=c()
a = 1/length(q)
qq=c(0,q)
for(i in 1:length(q)){mids = append(mids,(qq[i]+qq[i+1])/2);density=append(density,a/(qq[i+1]-qq[i]))}
res=list()
res$mids=mids;res$density=density
return(res)
}
quantilesToHist(1:10)
help("try")
tryCatch({x+1})
tryCatch({x+1},error=function(e){show("tos")})
tryCatch({x+1},error=function(e){return("tos")})
tryCatch({x+1},error=function(e){return(2)})
tryCatch({x+1},error=function(e){res=2})
res
library(raster)
help("focal")
strsplit("1998;2008;2554")
strsplit("1998;2008;2554",";")
strsplit("1998;2008;2554",";")[[1]]
kwNum = 100000
yearRange=c(1976,1977,1978,1979,1980)
year = paste0(as.character(yearRange[1]),"-",as.character(yearRange[length(yearRange)]))
paste0('relevant.relevant_',year,'_full_',kwNum)
paste0('relevant.relevant_',year,'_full_',kwNum)
5*6*3*10*5
5*6*3*10*5*3
5*6*3*10*5*3*20
5*6*3*10*5*7*20
getwd()
pop = load('Data/GibratSim/countriesPop.RData')
pop
CHina
China
library(dplyr)
as.tbl(China)
China[9000:9100,]
as.tbl(China_Historic)
mmax(China$`2010`)
max(China$`2010`)
hist(China$`2010`,breaks=500)
library(ggplot2)
g=ggplot(China)
d=data.frame()
for(j in 5:8){
d=rbind(d,cbind(sort(China[,j],decreasing = TRUE),1:nrow(China),rep(colnames(China)[j],nrow(China))))
}
sort(China[,j],decreasing = TRUE)
1:nrow(China)
d=data.frame()
for(j in 5:8){
d=rbind(d,data.frame(sort(China[,j],decreasing = TRUE),1:nrow(China),rep(colnames(China)[j],nrow(China))))
}
nrow(China)
China[,j]
d=data.frame()
for(j in 5:8){
d=rbind(d,data.frame(sort(China[,j],decreasing = TRUE,na.last = TRUE),1:nrow(China),rep(colnames(China)[j],nrow(China))))
}
colnames(d)<-c("size","rank","year")
colnames(d)
dim(d)
g=ggplot(d)
g+geom_point(aes(x=rnake,y=size,colour=year))
g+geom_point(aes(x=rank,y=size,colour=year))
g+geom_point(aes(x=log(rank),y=log(size),colour=year))
help("geom_bar")
192000 * 109 / 200
192000 * 109 / 200 / 3600
192000 * 109 / 200 / 3600 / 10
192000 * 109 / 200 / 3600 / 20
14/1.38
50*49/2
d=read.csv('/Users/Juste/Documents/ComplexSystems/EnergyPrice/Models/DataCollection/test/data/test_all.csv')
d=read.csv('/Users/Juste/Documents/ComplexSystems/EnergyPrice/Models/DataCollection/test/data/test_all.csv',sep=";")
d
head(d)
d=read.csv('/Users/Juste/Documents/ComplexSystems/EnergyPrice/Models/DataCollection/test/data/test_all.csv',sep=";",header=FALSE)
head(d)
head(d,n = 100)
which(d[,2]==0)
which(d[,2]==2)
unique(d[,2])
help(apply)
help(Matrix)
library(Matrix)
help("Matrix")
library(raster)
help("focal")
library(Matrix)
library(ggplot2)
library(dplyr)
library(reshape2)
setwd(paste0(Sys.getenv('CS_HOME'),'/PatentsMining/Models/Semantic'))
wyears = 1980:2012
windowSize=5
year=1980
load(paste0('probas/processed_counts_prim_',(year-windowSize+1),"-",year,'.RData'));load(paste0('probas/citadj_',(year-windowSize+1),"-",year,'.RData'));show(year)
technoprobas=currentprobas$technoprobas;semprobas=currentprobas$semprobas;primtechnoprobas=currentprobas$primarytechnoprobas;rm(currentprobas);gc()
probas=primtechnoprobas
membership = apply(probas,1,function(r){which(r>0)[1]})
sort(unique(membership))
diff(sort(unique(membership)))
c=1
deltac = sparseMatrix(1:nrow(adjacency),1:ncol(adjacency),x=0)
adjacency=currentadj
inds = which(membership==c)
length(inds)
deltac[inds,inds]=1
deltac = sparseMatrix(1:nrow(adjacency),1:ncol(adjacency),x=0)
deltac[inds,inds]=1
sum(deltac)
deltac[1,inds]=1
sum(deltac)
inds
help(sparseMatrix)
inds=c()
for(c in unique(membership)){inds = append(inds,which(membership==c))}
length(inds)
dim(adjacency)
head(inds)
directedmodularity<-function(membership,adjacency){
# sum([A_ij - k_iout k_j in/m ]\delta (c_i,c_j))
#
#deltac = sparseMatrix(1:nrow(adjacency),1:ncol(adjacency),x=0)
#inds=c()
#for(c in unique(membership)){inds = append(inds,which(membership==c))}
m=sum(adjacency)
kout=rowSums(adjacency);kin=colSums(adjacency)
res = 0;k=length(unique(membership))
for(c in unique(membership)){
if(c%%100==0){show(c/k)}
inds=which(membership==c)
res = res + sum(adjacency[inds,inds]) - sum(kin[inds])*sum(kout[inds])/m
}
return(res/m)
}
m=directedmodularity(membership,adjacency)
directedmodularity<-function(membership,adjacency){
# sum([A_ij - k_iout k_j in/m ]\delta (c_i,c_j))
#
#deltac = sparseMatrix(1:nrow(adjacency),1:ncol(adjacency),x=0)
#inds=c()
#for(c in unique(membership)){inds = append(inds,which(membership==c))}
m=sum(adjacency)
kout=rowSums(adjacency);kin=colSums(adjacency)
res = 0;k=length(unique(membership))
for(c in unique(membership)){
#if(c%%100==0){show(c/k)}
inds=which(membership==c)
res = res + sum(adjacency[inds,inds]) - sum(kin[inds])*sum(kout[inds])/m
}
return(res/m)
}
m
m=directedmodularity(membership,adjacency)
m
membership = apply(semprobas,1,function(r){which(r>0)[1]})
semmembership = apply(semprobas,1,function(r){which(r==max(r))[1]})
m=directedmodularity(semmembership,currentadj)
m
m*sum(adjacency)
year
year=2004
load(paste0('probas/processed_counts_prim_',(year-windowSize+1),"-",year,'.RData'));load(paste0('probas/citadj_',(year-windowSize+1),"-",year,'.RData'));show(year)
technoprobas=currentprobas$technoprobas;semprobas=currentprobas$semprobas;primtechnoprobas=currentprobas$primarytechnoprobas;rm(currentprobas);gc()
primtechmembership = apply(primtechnoprobas,1,function(r){which(r>0)[1]})
semmembership = apply(semprobas,1,function(r){which(r==max(r))[1]})
mtechno=directedmodularity(primtechmembership,currentadj)
msem=directedmodularity(semmembership,currentadj)
help(modularity)
library(igraph)
help(modularity)
g
sum(diag(currentadj))
g = graph_from_adjacency_matrix(currentadj,mode='out')
g = graph_from_adjacency_matrix(currentadj,directed=TRUE,mode='out')
g = graph_from_adjacency_matrix(currentadj,mode='directed')
g
dim(currentadj)
mg = modularity(g,primtechmembership)
mg
mtechno
mg = modularity(g,semmembership)
mg
help(modularity)
symadj=(currentadj+t(currentadj))/2
g = graph_from_adjacency_matrix(symadj,mode='undirected')
mg = modularity(g,semmembership)
mg
mg = modularity(g,primtechmembership)
mg
load(paste0('probas/processed_counts_prim_',(year-windowSize+1),"-",year,'.RData'));load(paste0('probas/citadj_',(year-windowSize+1),"-",year,'.RData'));show(year)
computemodularities<-function(currentprobas,currentadj){
technoprobas=currentprobas$technoprobas;semprobas=currentprobas$semprobas;primtechnoprobas=currentprobas$primarytechnoprobas;
res=list()
# overlapping modularities
res$technoovmod = overlappingmodularity(technoprobas,adjacency)
res$semovmod = overlappingmodularity(semprobas,adjacency)
# simple directed modularities
primtechmembership = apply(primtechnoprobas,1,function(r){which(r>0)[1]})
semmembership = apply(semprobas,1,function(r){which(r==max(r))[1]})
res$technodirmod=directedmodularity(primtechmembership,currentadj)
res$semdirmod=directedmodularity(semmembership,currentadj)
# igraph computed measures
symadj=(currentadj+t(currentadj))/2
gsim = graph_from_adjacency_matrix(symadj,mode='undirected')
g = graph_from_adjacency_matrix(currentadj,mode='directed')
res$technodirgraphmod = modularity(g,primtechmembership)
res$semdirgraphmod =  modularity(g,semmembership)
res$technoundirgraphmod = modularity(gsim,primtechmembership)
res$semundirgraphmod =  modularity(gsim,semmembership)
gc();
return(res)
}
m = computemodularities(currentprobas,currentadj)
##
#  Overlapping community modularity
#    implementing (Nicoasia et al., 2009)
#
#  simplified : linkfun = x1*x2, more efficient to compute ?
#  outer tensor product ? let do it dirtily with a loop
overlappingmodularity <- function(probas,adjacency){#,linkfun=function(p1,p2){return(p1*p2)}){
show(paste0('Computing overlapping modularity : dim(probas)=',dim(probas)[1],' ',dim(probas)[2],' ; dim(adjacency)=',dim(adjacency)[1],' ',dim(adjacency)[2]))
m = sum(adjacency)
n=nrow(probas)
kout=rowSums(adjacency)
kin=colSums(adjacency)
res=0
for(c in 1:ncol(probas)){
if(sum(probas[,c])>0){
if(c%%100==0){show(c/ncol(probas))}
a1 = Diagonal(x=probas[,c])%*%adjacency%*%Diagonal(x=probas[,c])
a2 = sum(kout*probas[,c])*sum(kin*probas[,c])*((sum(probas[,c])/n)^2)/m
res = res + sum(a1) - a2
rm(a1);gc() # loose time to call gc at each step ?
}
}
return(res/m)
}
##
# simple directed modularity
#
#  Test with probas = primtechnoprobas : membership = apply(probas,1,function(r){which(r>0)[1]})
#   NAs ?
directedmodularity<-function(membership,adjacency){
# sum([A_ij - k_iout k_j in/m ]\delta (c_i,c_j))
#
#deltac = sparseMatrix(1:nrow(adjacency),1:ncol(adjacency),x=0)
#inds=c()
#for(c in unique(membership)){inds = append(inds,which(membership==c))}
m=sum(adjacency)
kout=rowSums(adjacency);kin=colSums(adjacency)
res = 0;k=length(unique(membership))
for(c in unique(membership)){
#if(c%%100==0){show(c/k)}
inds=which(membership==c)
res = res + sum(adjacency[inds,inds]) - sum(kin[inds])*sum(kout[inds])/m
gc()
}
return(res/m)
}
m = computemodularities(currentprobas,currentadj)
rm(adjacency)
gc()
computemodularities<-function(currentprobas,currentadj){
technoprobas=currentprobas$technoprobas;semprobas=currentprobas$semprobas;primtechnoprobas=currentprobas$primarytechnoprobas;
res=list()
# overlapping modularities
res$technoovmod = overlappingmodularity(technoprobas,currentadj)
res$semovmod = overlappingmodularity(semprobas,currentadj)
# simple directed modularities
primtechmembership = apply(primtechnoprobas,1,function(r){which(r>0)[1]})
semmembership = apply(semprobas,1,function(r){which(r==max(r))[1]})
res$technodirmod=directedmodularity(primtechmembership,currentadj)
res$semdirmod=directedmodularity(semmembership,currentadj)
# igraph computed measures
symadj=(currentadj+t(currentadj))/2
gsim = graph_from_adjacency_matrix(symadj,mode='undirected')
g = graph_from_adjacency_matrix(currentadj,mode='directed')
res$technodirgraphmod = modularity(g,primtechmembership)
res$semdirgraphmod =  modularity(g,semmembership)
res$technoundirgraphmod = modularity(gsim,primtechmembership)
res$semundirgraphmod =  modularity(gsim,semmembership)
gc();
return(res)
}
m = computemodularities(currentprobas,currentadj)
m
m$year=year
m
load('res/modularities.RData')
modularities[1]
modularities[[1]]
sapply(modularities,function(l){l$technoovmod})
plot(sapply(modularities,function(l){l$technoovmod}))
plot(sapply(modularities,function(l){l$semovmod}))
df = data.frame(year=sapply(modularities,function(l){l$year}),
technoovmod=sapply(modularities,function(l){l$technoovmod}),
semovmod=sapply(modularities,function(l){l$semovmod}),
technodirmod=sapply(modularities,function(l){l$semovmod}),
semdirmod=sapply(modularities,function(l){l$semdirmod}),
technodirgraphmod=sapply(modularities,function(l){l$technodirgraphmod}),
semdirgraphmod=sapply(modularities,function(l){l$semdirgraphmod}),
technoundirgraphmod=sapply(modularities,function(l){l$technoundirgraphmod}),
semundirgraphmod=sapply(modularities,function(l){l$semundirgraphmod}),
)
sapply(modularities,function(l){l$year})
data.frame(year=sapply(modularities,function(l){l$year}))
data.frame(year=sapply(modularities,function(l){l$year}),
technoovmod=sapply(modularities,function(l){l$technoovmod}))
df = data.frame(year=sapply(modularities,function(l){l$year}),
technoovmod=sapply(modularities,function(l){l$technoovmod}),
semovmod=sapply(modularities,function(l){l$semovmod}),
technodirmod=sapply(modularities,function(l){l$semovmod}),
semdirmod=sapply(modularities,function(l){l$semdirmod}),
technodirgraphmod=sapply(modularities,function(l){l$technodirgraphmod}),
semdirgraphmod=sapply(modularities,function(l){l$semdirgraphmod}),
technoundirgraphmod=sapply(modularities,function(l){l$technoundirgraphmod}),
semundirgraphmod=sapply(modularities,function(l){l$semundirgraphmod})
)
df
g=ggplot(df)
g+geom_line(aes(x=year,y=technoovmod))
g+geom_line(aes(x=year,y=semovmod))
g+geom_line(aes(x=year,y=technodirmod))
g+geom_line(aes(x=year,y=technodirmod))
g+geom_line(aes(x=year,y=semovmod))
g+geom_line(aes(x=year,y=technodirmod))
df = data.frame(year=sapply(modularities,function(l){l$year}),
technoovmod=sapply(modularities,function(l){l$technoovmod}),
semovmod=sapply(modularities,function(l){l$semovmod}),
technodirmod=sapply(modularities,function(l){l$technodirmod}),
semdirmod=sapply(modularities,function(l){l$semdirmod}),
technodirgraphmod=sapply(modularities,function(l){l$technodirgraphmod}),
semdirgraphmod=sapply(modularities,function(l){l$semdirgraphmod}),
technoundirgraphmod=sapply(modularities,function(l){l$technoundirgraphmod}),
semundirgraphmod=sapply(modularities,function(l){l$semundirgraphmod})
)
g+geom_line(aes(x=year,y=technodirmod))
g=ggplot(df)
g+geom_line(aes(x=year,y=technoovmod))
g+geom_line(aes(x=year,y=semovmod))
g+geom_line(aes(x=year,y=technodirmod))
g+geom_line(aes(x=year,y=semdirmod))
g+geom_line(aes(x=year,y=technodirgraphmod))
g+geom_line(aes(x=year,y=technodirmod))
g+geom_line(aes(x=year,y=semdirgraphmod))
g+geom_line(aes(x=year,y=semdirmod))
g+geom_line(aes(x=year,y=semdirgraphmod))
g+geom_line(aes(x=year,y=technoovmod-max(technoovmod)/(min(technoovmod)-max(technoovmod))))
g+geom_line(aes(x=year,y=technoovmod-min(technoovmod)/(max(technoovmod)-min(technoovmod))))
min(technoovmod)
g+geom_line(aes(x=year,y=semovmod))+geom_line(aes(x=year,y=technodirmod))
g+geom_line(aes(x=year,y=semovmod,colour=1))+geom_line(aes(x=year,y=technodirmod,colour=2))
g+geom_line(aes(x=year,y=semovmod,colour="semantic"))+geom_line(aes(x=year,y=technodirmod,colour="techno"))
g+geom_line(aes(x=year,y=technoovmod,colour="techno"))+geom_line(aes(x=year,y=semovmod,colour="semantic"))
g+geom_line(aes(x=year,y=technodirmod,colour="techno"))+geom_line(aes(x=year,y=semdirmod,colour="semantic"))
g+geom_line(aes(x=year,y=technoovmod,colour="techno"))+geom_line(aes(x=year,y=semovmod,colour="semantic"))
g+geom_line(aes(x=year,y=technodirmod,colour="techno"))+geom_line(aes(x=year,y=semdirmod,colour="semantic"))
